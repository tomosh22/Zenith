#version 450

// Compute shader for GPU-driven terrain chunk culling
// This runs once per terrain chunk and tests if it's visible in the camera frustum

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Chunk data structure - matches CPU-side TerrainChunkData
struct TerrainChunkData
{
    vec4 aabbMin;  // xyz = min corner, w = padding
    vec4 aabbMax;  // xyz = max corner, w = padding
    uint firstIndex;
    uint indexCount;
    uint vertexOffset;
    uint padding;
};

// Indirect draw command structure - matches VkDrawIndexedIndirectCommand
struct DrawIndexedIndirectCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;      // int to match VkDrawIndexedIndirectCommand
    uint firstInstance;
};

// Camera frustum plane in the form: dot(normal, point) + distance = 0
struct FrustumPlane
{
    vec4 normalAndDistance;  // xyz = normal, w = distance
};

// Input: chunk data (read-only)
layout(std140, set = 0, binding = 0) readonly buffer ChunkBuffer
{
    TerrainChunkData chunks[];
};

// Input: frustum planes extracted from viewProjection matrix
layout(std140, set = 0, binding = 1) uniform FrustumBuffer
{
    FrustumPlane frustumPlanes[6];  // Left, Right, Bottom, Top, Near, Far
};

// Output: indirect draw commands (one per chunk)
// Visible chunks will have indexCount > 0, non-visible chunks will have indexCount = 0
layout(std430, set = 0, binding = 2) buffer IndirectCommandBuffer
{
    DrawIndexedIndirectCommand drawCommands[];
};

// Test if an AABB intersects with the frustum
// Uses the "p-vertex" method for efficient testing
bool testAABBFrustum(vec3 aabbMin, vec3 aabbMax)
{
    vec3 center = (aabbMin + aabbMax) * 0.5;
    vec3 extents = (aabbMax - aabbMin) * 0.5;

    // Test against each frustum plane
    for (int i = 0; i < 6; ++i)
    {
        vec3 planeNormal = frustumPlanes[i].normalAndDistance.xyz;
        float planeDistance = frustumPlanes[i].normalAndDistance.w;

        // Calculate the radius - the maximum extent of the AABB in the direction of the plane normal
        float radius = 
            extents.x * abs(planeNormal.x) +
            extents.y * abs(planeNormal.y) +
            extents.z * abs(planeNormal.z);

        // Calculate signed distance from center to plane
        float distance = dot(planeNormal, center) + planeDistance;

        // If center + radius is behind the plane, the entire AABB is outside
        if (distance < -radius)
        {
            return false;  // AABB is completely outside this plane
        }
    }

    // AABB passed all plane tests - it's at least partially visible
    return true;
}

void main()
{
    uint chunkIndex = gl_GlobalInvocationID.x;
    
    // Bounds check (we may have launched more threads than chunks)
    if (chunkIndex >= chunks.length())
        return;

    // Get chunk data
    TerrainChunkData chunk = chunks[chunkIndex];
    
    // Perform frustum culling test
    bool isVisible = testAABBFrustum(chunk.aabbMin.xyz, chunk.aabbMax.xyz);
    
    // Write the indirect draw command directly at the chunk's index
    // If visible, write the actual draw command; if not visible, write indexCount=0 to skip it
    if (isVisible)
    {
        drawCommands[chunkIndex].indexCount = chunk.indexCount;
        drawCommands[chunkIndex].instanceCount = 1;
        drawCommands[chunkIndex].firstIndex = chunk.firstIndex;
        drawCommands[chunkIndex].vertexOffset = int(chunk.vertexOffset);
        drawCommands[chunkIndex].firstInstance = 0;
    }
    else
    {
        // Write a command with indexCount=0 which will be skipped by the GPU
        drawCommands[chunkIndex].indexCount = 0;
        drawCommands[chunkIndex].instanceCount = 0;
        drawCommands[chunkIndex].firstIndex = 0;
        drawCommands[chunkIndex].vertexOffset = 0;
        drawCommands[chunkIndex].firstInstance = 0;
    }
}
