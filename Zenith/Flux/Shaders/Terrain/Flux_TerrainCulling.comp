#version 450

// Compute shader for GPU-driven terrain chunk culling with LOD selection and front-to-back sorting
// This runs once per terrain chunk, tests visibility, selects appropriate LOD based on distance,
// calculates distance, and writes sorted draw commands

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Number of LOD levels per chunk
#define TERRAIN_LOD_COUNT 4

// LOD data for a single level
struct LODData
{
    uint firstIndex;
    uint indexCount;
    uint vertexOffset;
    float maxDistanceSq;  // Maximum distance squared at which this LOD is used
};

// Chunk data structure - matches CPU-side TerrainChunkData
struct TerrainChunkData
{
    vec4 aabbMin;               // xyz = min corner, w = padding
    vec4 aabbMax;               // xyz = max corner, w = padding
    LODData lods[TERRAIN_LOD_COUNT];  // LOD mesh data (LOD0=highest detail)
};

// Indirect draw command structure - matches VkDrawIndexedIndirectCommand
struct DrawIndexedIndirectCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;      // int to match VkDrawIndexedIndirectCommand
    uint firstInstance;
};

// Camera frustum plane in the form: dot(normal, point) + distance = 0
struct FrustumPlane
{
    vec4 normalAndDistance;  // xyz = normal, w = distance
};

// Visible chunk data for sorting
struct VisibleChunkData
{
    uint chunkIndex;
    uint lodLevel;              // Selected LOD level (0-3)
    float distanceSquared;      // Distance squared to camera (for front-to-back sorting)
};

// Input: chunk data (read-only)
layout(std140, set = 0, binding = 0) readonly buffer ChunkBuffer
{
    TerrainChunkData chunks[];
};

// Input: frustum planes and camera position extracted from viewProjection matrix
layout(std140, set = 0, binding = 1) uniform CameraBuffer
{
    FrustumPlane frustumPlanes[6];  // Left, Right, Bottom, Top, Near, Far
    vec4 cameraPosition;             // xyz = camera position, w = padding
};

// Output: indirect draw commands (one per chunk)
layout(std430, set = 0, binding = 2) buffer IndirectCommandBuffer
{
    DrawIndexedIndirectCommand drawCommands[];
};

// Output: atomic counter for visible chunks
layout(std430, set = 0, binding = 3) buffer VisibleCountBuffer
{
    uint visibleCount;
};

// Shared memory for sorting visible chunks within workgroup
shared VisibleChunkData s_visibleChunks[64];
shared uint s_localVisibleCount;

// Test if an AABB intersects with the frustum
bool testAABBFrustum(vec3 aabbMin, vec3 aabbMax)
{
    vec3 center = (aabbMin + aabbMax) * 0.5;
    vec3 extents = (aabbMax - aabbMin) * 0.5;

    // Test against each frustum plane
    for (int i = 0; i < 6; ++i)
    {
        vec3 planeNormal = frustumPlanes[i].normalAndDistance.xyz;
        float planeDistance = frustumPlanes[i].normalAndDistance.w;

        // Calculate the radius - the maximum extent of the AABB in the direction of the plane normal
        float radius = 
            extents.x * abs(planeNormal.x) +
            extents.y * abs(planeNormal.y) +
            extents.z * abs(planeNormal.z);

        // Calculate signed distance from center to plane
        float distance = dot(planeNormal, center) + planeDistance;

        // If center + radius is behind the plane, the entire AABB is outside
        if (distance < -radius)
        {
            return false;  // AABB is completely outside this plane
        }
    }

    // AABB passed all plane tests - it's at least partially visible
    return true;
}

// Select appropriate LOD level based on distance squared
uint selectLOD(float distanceSq, TerrainChunkData chunk)
{
    // LOD selection based on distance thresholds
    // LODs are ordered from highest detail (LOD0) to lowest (LOD3)
    for (uint i = 0; i < TERRAIN_LOD_COUNT; ++i)
    {
        if (distanceSq < chunk.lods[i].maxDistanceSq)
        {
            return i;
        }
    }
    
    // If distance exceeds all thresholds, use lowest LOD
    return TERRAIN_LOD_COUNT - 1;
}

void main()
{
    uint chunkIndex = gl_GlobalInvocationID.x;
    uint localIndex = gl_LocalInvocationID.x;
    
    // Initialize shared memory on first thread
    if (localIndex == 0)
    {
        s_localVisibleCount = 0;
    }
    barrier();
    
    // Bounds check (we may have launched more threads than chunks)
    if (chunkIndex >= chunks.length())
        return;

    // Get chunk data
    TerrainChunkData chunk = chunks[chunkIndex];
    
    // Perform frustum culling test
    bool isVisible = testAABBFrustum(chunk.aabbMin.xyz, chunk.aabbMax.xyz);
    
    if (isVisible)
    {
        // Calculate distance squared from camera to chunk center (for LOD selection and sorting)
        vec3 chunkCenter = (chunk.aabbMin.xyz + chunk.aabbMax.xyz) * 0.5;
        vec3 toCameraVec = cameraPosition.xyz - chunkCenter;
        float distSq = dot(toCameraVec, toCameraVec);
        
        // Select appropriate LOD level based on distance
        uint lodLevel = selectLOD(distSq, chunk);
        
        // Add to local visible list
        uint localSlot = atomicAdd(s_localVisibleCount, 1);
        if (localSlot < 64)
        {
            s_visibleChunks[localSlot].chunkIndex = chunkIndex;
            s_visibleChunks[localSlot].lodLevel = lodLevel;
            s_visibleChunks[localSlot].distanceSquared = distSq;
        }
    }
    
    barrier();
    
    // Sort visible chunks within workgroup (simple insertion sort for small arrays)
    // Only thread 0 does the sorting
    if (localIndex == 0 && s_localVisibleCount > 0)
    {
        uint count = min(s_localVisibleCount, 64);
        
        // Insertion sort: front-to-back (closest first)
        // This improves depth buffer efficiency and early-Z culling
        for (uint i = 1; i < count; ++i)
        {
            VisibleChunkData key = s_visibleChunks[i];
            int j = int(i) - 1;
            
            while (j >= 0 && s_visibleChunks[j].distanceSquared > key.distanceSquared)
            {
                s_visibleChunks[j + 1] = s_visibleChunks[j];
                j--;
            }
            s_visibleChunks[j + 1] = key;
        }
        
        // Write sorted visible chunks to output buffer with selected LOD
        uint baseIndex = atomicAdd(visibleCount, count);
        for (uint i = 0; i < count; ++i)
        {
            uint outIndex = baseIndex + i;
            uint srcChunkIndex = s_visibleChunks[i].chunkIndex;
            uint srcLODLevel = s_visibleChunks[i].lodLevel;
            
            TerrainChunkData srcChunk = chunks[srcChunkIndex];
            LODData selectedLOD = srcChunk.lods[srcLODLevel];
            
            // Write indirect draw command with selected LOD mesh data
            drawCommands[outIndex].indexCount = selectedLOD.indexCount;
            drawCommands[outIndex].instanceCount = 1;
            drawCommands[outIndex].firstIndex = selectedLOD.firstIndex;
            drawCommands[outIndex].vertexOffset = int(selectedLOD.vertexOffset);
            drawCommands[outIndex].firstInstance = 0;
        }
    }
}
