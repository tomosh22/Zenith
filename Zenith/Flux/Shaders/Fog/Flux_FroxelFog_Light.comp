#version 450

#include "../Common.fxh"
#include "Flux_VolumetricCommon.fxh"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Bindings (binding 0 is FrameConstants from Common.fxh)
layout(set = 0, binding = 1) uniform sampler3D u_xDensityGrid;
layout(set = 0, binding = 2, rgba16f) uniform writeonly image3D u_xLightingGrid;
layout(set = 0, binding = 3, rgba16f) uniform writeonly image3D u_xScatteringGrid;

// Push constants
layout(push_constant) uniform LightConstants
{
    vec4 u_xFogColour;
    vec4 u_xLightDirection;
    vec4 u_xLightColour;       // RGB = color, A = intensity
    vec4 u_xGridDimensions;
    float u_fScatteringCoeff;
    float u_fAbsorptionCoeff;
    float u_fPhaseG;
    uint u_uDebugMode;
};

// Debug mode constants
const uint DEBUG_FROXEL_SCATTERING = 6;
const uint DEBUG_FROXEL_EXTINCTION = 7;
const uint DEBUG_FROXEL_SHADOW_SAMPLES = 8;

void main()
{
    ivec3 froxelCoord = ivec3(gl_GlobalInvocationID.xyz);

    // Bounds check
    if (froxelCoord.x >= int(u_xGridDimensions.x) ||
        froxelCoord.y >= int(u_xGridDimensions.y) ||
        froxelCoord.z >= int(u_xGridDimensions.z))
    {
        return;
    }

    // Sample density at this froxel
    vec4 densityData = texelFetch(u_xDensityGrid, froxelCoord, 0);
    float density = densityData.r;
    float scatteringCoeff = densityData.g;
    float absorptionCoeff = densityData.b;

    // Skip empty froxels
    if (density < 0.0001)
    {
        imageStore(u_xLightingGrid, froxelCoord, vec4(0.0, 0.0, 0.0, 0.0));
        imageStore(u_xScatteringGrid, froxelCoord, vec4(0.0, 0.0, 0.0, 0.0));
        return;
    }

    // Calculate view direction for this froxel (towards camera)
    vec2 uv = (vec2(froxelCoord.xy) + 0.5) / u_xGridDimensions.xy;
    vec2 ndc = uv * 2.0 - 1.0;
    vec4 clipPos = vec4(ndc, 0.5, 1.0);
    vec4 viewPos = inverse(g_xProjMat) * clipPos;
    vec3 viewDir = -normalize(viewPos.xyz);

    // Light direction (towards light) - use sun direction from Common.fxh
    vec3 lightDir = normalize(-g_xSunDir_Pad.xyz);

    // Phase function
    float cosTheta = dot(viewDir, lightDir);
    float phase = HenyeyGreenstein(cosTheta, u_fPhaseG);

    // Light color and intensity from Common.fxh
    vec3 lightColor = g_xSunColour.rgb * u_xLightColour.a;

    // In-scattering contribution
    // TODO: Add shadow sampling for volumetric shadows
    float shadowTerm = 1.0;  // Simplified - no shadows

    vec3 inScatter = lightColor * scatteringCoeff * phase * shadowTerm;

    // Ambient contribution (from fog color)
    vec3 ambient = u_xFogColour.rgb * scatteringCoeff * 0.2;

    // Total in-scatter
    vec3 totalScatter = inScatter + ambient;

    // Extinction coefficient
    float extinction = scatteringCoeff + absorptionCoeff;

    // Debug visualizations
    if (u_uDebugMode == DEBUG_FROXEL_SCATTERING)
    {
        // Heat map of scattering (blue = low, red = high)
        float scatterMag = length(totalScatter);
        vec3 heatColor = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), clamp(scatterMag * 2.0, 0.0, 1.0));
        imageStore(u_xLightingGrid, froxelCoord, vec4(heatColor, 1.0));
        imageStore(u_xScatteringGrid, froxelCoord, vec4(totalScatter, extinction));
        return;
    }

    if (u_uDebugMode == DEBUG_FROXEL_EXTINCTION)
    {
        // Visualize extinction (white = clear, black = opaque)
        float transmittance = exp(-extinction);
        imageStore(u_xLightingGrid, froxelCoord, vec4(vec3(transmittance), 1.0));
        imageStore(u_xScatteringGrid, froxelCoord, vec4(totalScatter, extinction));
        return;
    }

    if (u_uDebugMode == DEBUG_FROXEL_SHADOW_SAMPLES)
    {
        // Visualize shadow sample positions (where we'd sample shadow map)
        // For now just show light-facing froxels
        float facing = max(0.0, dot(viewDir, lightDir));
        imageStore(u_xLightingGrid, froxelCoord, vec4(facing, 0.0, 0.0, 1.0));
        imageStore(u_xScatteringGrid, froxelCoord, vec4(totalScatter, extinction));
        return;
    }

    // Store lighting and scattering data
    // Lighting grid: RGB = accumulated in-scatter, A = unused
    // Scattering grid: RGB = per-step in-scatter, A = extinction
    imageStore(u_xLightingGrid, froxelCoord, vec4(totalScatter, 1.0));
    imageStore(u_xScatteringGrid, froxelCoord, vec4(totalScatter, extinction));
}
