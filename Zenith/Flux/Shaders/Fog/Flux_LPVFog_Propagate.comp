#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Bindings
layout(set = 0, binding = 0) uniform sampler3D u_xLPVInput;
layout(set = 0, binding = 1, rgba16f) uniform writeonly image3D u_xLPVOutput;

// Push constants
layout(push_constant) uniform PropagateConstants
{
    vec4 u_xGridDimensions;
    uint u_uIterationIndex;
    uint u_uCascadeIndex;
    float u_fDamping;
    uint u_uDebugMode;
};

// Debug mode constants
const uint DEBUG_LPV_PROPAGATION_ITER = 14;
const uint DEBUG_LPV_SH_COEFFICIENTS = 16;

// 6 face directions for propagation
const vec3 FACE_DIRS[6] = vec3[6](
    vec3( 1.0,  0.0,  0.0),  // +X
    vec3(-1.0,  0.0,  0.0),  // -X
    vec3( 0.0,  1.0,  0.0),  // +Y
    vec3( 0.0, -1.0,  0.0),  // -Y
    vec3( 0.0,  0.0,  1.0),  // +Z
    vec3( 0.0,  0.0, -1.0)   // -Z
);

// Solid angle weights for each face (approximation)
const float SOLID_ANGLE_WEIGHT = 0.25;  // 1/4 of hemisphere

void main()
{
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID.xyz);

    // Bounds check
    if (gridCoord.x >= int(u_xGridDimensions.x) ||
        gridCoord.y >= int(u_xGridDimensions.y) ||
        gridCoord.z >= int(u_xGridDimensions.z))
    {
        return;
    }

    // Current cell's light
    vec4 currentLight = texelFetch(u_xLPVInput, gridCoord, 0);

    // Accumulate incoming light from all 6 neighbors
    vec3 incomingLight = vec3(0.0);

    for (int face = 0; face < 6; face++)
    {
        // Get neighbor coordinate
        ivec3 neighborCoord = gridCoord + ivec3(FACE_DIRS[face]);

        // Bounds check for neighbor
        if (neighborCoord.x >= 0 && neighborCoord.x < int(u_xGridDimensions.x) &&
            neighborCoord.y >= 0 && neighborCoord.y < int(u_xGridDimensions.y) &&
            neighborCoord.z >= 0 && neighborCoord.z < int(u_xGridDimensions.z))
        {
            // Sample neighbor's light
            vec4 neighborLight = texelFetch(u_xLPVInput, neighborCoord, 0);

            // Direction from neighbor to this cell
            vec3 propDir = -FACE_DIRS[face];

            // Simplified propagation: assume light spreads in all directions
            // Real LPV uses SH evaluation for directional propagation
            float contribution = SOLID_ANGLE_WEIGHT;

            incomingLight += neighborLight.rgb * contribution;
        }
    }

    // Apply damping to prevent energy explosion
    incomingLight *= u_fDamping;

    // Add to existing light (preserve injected light, add propagated)
    vec3 resultLight = currentLight.rgb + incomingLight;

    // Debug: Show propagation iteration progress
    if (u_uDebugMode == DEBUG_LPV_PROPAGATION_ITER)
    {
        // Color code by iteration (cycle through colors)
        float iterColor = float(u_uIterationIndex % 8) / 8.0;
        resultLight = mix(resultLight, vec3(iterColor, 1.0 - iterColor, 0.5), 0.3);
    }

    if (u_uDebugMode == DEBUG_LPV_SH_COEFFICIENTS)
    {
        // Visualize light magnitude
        float magnitude = length(resultLight);
        resultLight = vec3(magnitude);
    }

    imageStore(u_xLPVOutput, gridCoord, vec4(resultLight, 1.0));
}
