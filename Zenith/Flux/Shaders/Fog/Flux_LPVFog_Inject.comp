#version 450

#include "../Common.fxh"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Scratch buffer for push constants replacement
layout(std140, set = 0, binding = 1) uniform InjectConstants
{
    vec4 u_xLightDirection;    // xyz = direction, w = unused
    vec4 u_xLightColour;       // RGB = color, A = intensity
    vec4 u_xCascadeCenter;     // xyz = center, w = radius
    uint u_uGridSize;
    uint u_uCascadeIndex;
    float u_fCascadeRadius;
    float u_fPad0;
};

// Bindings (binding 0 is FrameConstants from Common.fxh)
layout(set = 0, binding = 2) uniform sampler2D u_xShadowMap;
layout(set = 0, binding = 3, rgba16f) uniform writeonly image3D u_xLPVOutput;
layout(set = 0, binding = 4, rgba16f) uniform writeonly image2D u_xDebugInjection;

// Debug mode constants
const uint DEBUG_LPV_INJECTION_POINTS = 13;

// Convert grid coordinate to world position
vec3 GridToWorld(ivec3 gridCoord)
{
    vec3 gridNorm = (vec3(gridCoord) + 0.5) / float(u_uGridSize);
    vec3 offset = (gridNorm - 0.5) * 2.0 * u_fCascadeRadius;
    return u_xCascadeCenter.xyz + offset;
}

// Simplified visibility test based on light direction
// (Real implementation would sample from shadow map)
float GetLightVisibility(vec3 worldPos, ivec3 gridCoord)
{
    // Use noise texture for variation (placeholder for shadow map)
    vec2 noiseUV = vec2(gridCoord.xy) / float(u_uGridSize);
    float noise = texture(u_xShadowMap, noiseUV).r;

    // Height-based falloff - more light at higher grid positions along light direction
    vec3 lightDir = normalize(u_xLightDirection.xyz);
    float heightFactor = dot(vec3(gridCoord) / float(u_uGridSize), -lightDir);
    heightFactor = clamp(heightFactor * 0.5 + 0.5, 0.0, 1.0);

    // Combine with noise for variation
    return mix(0.3, 1.0, heightFactor) * mix(0.8, 1.0, noise);
}

void main()
{
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID.xyz);

    // Bounds check
    if (gridCoord.x >= int(u_uGridSize) ||
        gridCoord.y >= int(u_uGridSize) ||
        gridCoord.z >= int(u_uGridSize))
    {
        return;
    }

    // Get world position for this cell
    vec3 worldPos = GridToWorld(gridCoord);

    // Get light visibility for this cell
    float visibility = GetLightVisibility(worldPos, gridCoord);

    // Store incoming light flux using sun color from Common.fxh
    // RGB = directional light contribution, A = unused
    vec3 lightFlux = g_xSunColour.rgb * u_xLightColour.a * visibility;

    // Simplified: store light flux directly (real LPV uses SH coefficients)
    imageStore(u_xLPVOutput, gridCoord, vec4(lightFlux, 1.0));

    // Debug: Write to 2D debug texture (slice at z = gridSize/2)
    if (gridCoord.z == int(u_uGridSize / 2))
    {
        imageStore(u_xDebugInjection, gridCoord.xy, vec4(lightFlux, 1.0));
    }
}
